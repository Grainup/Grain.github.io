<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>01.django_学习day01</title>
    <link href="/2023/11/20/01-django%E7%AC%AC%E4%B8%80%E4%B8%AA%E9%A1%B9%E7%9B%AE/"/>
    <url>/2023/11/20/01-django%E7%AC%AC%E4%B8%80%E4%B8%AA%E9%A1%B9%E7%9B%AE/</url>
    
    <content type="html"><![CDATA[<h1 id="第一个Django项目"><a href="#第一个Django项目" class="headerlink" title="第一个Django项目"></a>第一个Django项目</h1><p>pycharm创建一个Django项目，项目文件目录如下：</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs 1c">day01/ <span class="hljs-meta"># 根目录</span><br>    manage.py <span class="hljs-meta"># Django命令行工具</span><br>    day01/ <span class="hljs-meta"># 项目配置目录</span><br>        __init__.py <span class="hljs-meta"># 空文件，告诉python这个目录是python包</span><br>        settings.py <span class="hljs-meta"># 项目配置文件</span><br>        urls.py <span class="hljs-meta"># 项目所有urls声明汇总</span><br>        asgi.py <span class="hljs-meta"># ASGI服务器的入口文件</span><br>        wsgi.py <span class="hljs-meta"># WSGI服务器的入口文件</span><br></code></pre></td></tr></table></figure><ul><li>pycharm创建项目会默认穿件一个templates文件夹【需要删除】</li><li>在settings.py中【删除】“DIRS”:[<strong>os.path.join(BASE_DIR, ‘templates’)</strong>] ——&gt; “DIRS”:[]</li></ul><h3 id="1、终端运行"><a href="#1、终端运行" class="headerlink" title="1、终端运行"></a>1、终端运行</h3><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs py">python manage.py runserver<br></code></pre></td></tr></table></figure><p><strong>更换端口：</strong></p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs py">python manage.py runserver <span class="hljs-number">8080</span><br></code></pre></td></tr></table></figure><h3 id="2、创建应用APP"><a href="#2、创建应用APP" class="headerlink" title="2、创建应用APP"></a>2、创建应用APP</h3><p>**1-**在manage.py同级目录下创建新应用：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs py">python manage.py startapp demo<br></code></pre></td></tr></table></figure><p>这将会创建一个 <code>demo</code> 目录，它的目录结构大致如下：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs stylus">demo/<br>    __init__<span class="hljs-selector-class">.py</span><br>    admin<span class="hljs-selector-class">.py</span>【固定不用动】Django默认提供了admin后台管理<br>    apps<span class="hljs-selector-class">.py</span>【固定不用动】app启动类<br>    migrations/【固定不用动】数据库变更记录<br>        __init__<span class="hljs-selector-class">.py</span><br>    models<span class="hljs-selector-class">.py</span>【重要】 对数据库操作<br>    tests<span class="hljs-selector-class">.py</span>【固定不用动】单元测试的<br>    views<span class="hljs-selector-class">.py</span>【重要】 视图函数<br></code></pre></td></tr></table></figure><p>**2-**在项目配置文件<code>day01\settings.py</code>的INSTALLED_APPS中加入demo</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python">INSTALLED_APPS = [<br>    <span class="hljs-string">&#x27;django.contrib.admin&#x27;</span>,<br>    <span class="hljs-string">&#x27;django.contrib.auth&#x27;</span>,<br>    <span class="hljs-string">&#x27;django.contrib.contenttypes&#x27;</span>,<br>    <span class="hljs-string">&#x27;django.contrib.sessions&#x27;</span>,<br>    <span class="hljs-string">&#x27;django.contrib.messages&#x27;</span>,<br>    <span class="hljs-string">&#x27;django.contrib.staticfiles&#x27;</span>,<br>    <span class="hljs-string">&#x27;demo&#x27;</span>, <span class="hljs-comment"># 注册app</span><br>]<br></code></pre></td></tr></table></figure><p>**3-**然后编辑<code>day01/urls.py</code>, 把demo应用的urls也加入到项目的urls中去，如下所示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">urlpatterns = [<br>    path(<span class="hljs-string">&#x27;admin/&#x27;</span>, admin.site.urls),<br>    path(<span class="hljs-string">&#x27;&#x27;</span>, include(<span class="hljs-string">&#x27;demo.urls&#x27;</span>)) <span class="hljs-comment"># 加入app对应urls</span><br>]<br></code></pre></td></tr></table></figure><img src="https://gitee.com/xiatian_grain/note_pic/raw/master/img/20231120221029.png" alt="image-20231120101528546" style="zoom:80%;" /><h3 id="3、编写视图函数和URL配置"><a href="#3、编写视图函数和URL配置" class="headerlink" title="3、编写视图函数和URL配置"></a>3、编写视图函数和URL配置</h3><p>**1-**编辑<code>demo/views.py</code>, 新增一个名为index的视图函数。每个视图函数的第一个默认参数都必需是<code>request</code>, 它是一个全局变量。Django把每个用户请求封装成了<code>request</code>对象，它包含里当前请求的所有信息，比如请求路径<code>request.path</code>, 当前用户<code>request.user</code>以及用户通过POST提交的数据<code>request.POST</code>。</p><p>index视图函数通过调用<code>HttpReponse</code>方法打印输出当前的请求路径<code>request.path</code>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># demo/views.py</span><br><span class="hljs-keyword">from</span> django.http <span class="hljs-keyword">import</span> HttpResponse<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">index</span>(<span class="hljs-params">request</span>):<br>    <span class="hljs-keyword">return</span> HttpResponse(<span class="hljs-string">&quot;Hello, world. You&#x27;re at the polls index.&quot;</span>)<br></code></pre></td></tr></table></figure><img src="https://gitee.com/xiatian_grain/note_pic/raw/master/img/20231120221040.png" alt="image-20231120101758204" style="zoom:75%;" /><p>**2-**使用<code> python manage.py runserver</code>重启服务器，打开<a href="http://127.0.0.1:8000/index/%E4%BC%9A%E6%98%BE%E7%A4%BA%22Hello">http://127.0.0.1:8000/index/会显示&quot;Hello</a>, world. You’re at the polls index.”</p><h3 id="4、templates模板"><a href="#4、templates模板" class="headerlink" title="4、templates模板"></a>4、templates模板</h3><p>返回html页面需要使用render</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 默认去当前目录下的templates文件夹中寻找对应html文件（根据app注册顺序找 ）</span><br>  <span class="hljs-keyword">return</span> render(request,<span class="hljs-string">&quot;XXX.html&quot;</span>)<br></code></pre></td></tr></table></figure><h3 id="5、静态文件"><a href="#5、静态文件" class="headerlink" title="5、静态文件"></a>5、静态文件</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs -">-static<br>-css【存放CSS样式】<br>-img 【存放图片】<br>-js【存放js样式】<br></code></pre></td></tr></table></figure><h4 id="加载静态文件"><a href="#加载静态文件" class="headerlink" title="加载静态文件"></a>加载静态文件</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># req.html</span><br>&#123;% load static %&#125;<span class="hljs-comment"># 加载</span><br></code></pre></td></tr></table></figure><img src="https://gitee.com/xiatian_grain/note_pic/raw/master/img/20231120221047.png" alt="image-20231120110846092" style="zoom:80%;" /><h2 id="模板语法"><a href="#模板语法" class="headerlink" title="模板语法"></a>模板语法</h2><h3 id="1、列表"><a href="#1、列表" class="headerlink" title="1、列表"></a>1、列表</h3><p>在render中添加一个字典，引入变量。读取列表，需要通过. 去索引</p><p><img src="https://gitee.com/xiatian_grain/note_pic/raw/master/img/20231120221053.png" alt="image-20231120114142547"></p><h3 id="2、for语法，进行循环读取"><a href="#2、for语法，进行循环读取" class="headerlink" title="2、for语法，进行循环读取"></a>2、for语法，进行循环读取</h3><p><img src="https://gitee.com/xiatian_grain/note_pic/raw/master/img/2023-11-20-21:47-44.png" alt="image-20231120155003475"></p><h3 id="3、读取字典"><a href="#3、读取字典" class="headerlink" title="3、读取字典"></a><strong>3、读取字典</strong></h3><ul><li>可以根据字典的键去获取值：、</li><li>或者for循环键</li></ul><img src="https://gitee.com/xiatian_grain/note_pic/raw/master/img/20231120221059.png" alt="image-20231120155818311" style="zoom:80%;" /><h3 id="4、判断语句if"><a href="#4、判断语句if" class="headerlink" title="4、判断语句if"></a>4、判断语句if</h3><p><img src="https://gitee.com/xiatian_grain/note_pic/raw/master/img/20231120221115.png" alt="image-20231120160600216"></p><img src="https://gitee.com/xiatian_grain/note_pic/raw/master/img/20231120221130.png" alt="image-20231120160954459" style="zoom:80%;" /><h2 id="请求和响应"><a href="#请求和响应" class="headerlink" title="请求和响应"></a>请求和响应</h2><p><strong>响应方式：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">return</span> HttpResponse(<span class="hljs-string">&quot;返回请求&quot;</span>)<span class="hljs-comment"># 将字符串内容返回给请求者</span><br><span class="hljs-keyword">return</span> render(request,<span class="hljs-string">&#x27;xxx.html&#x27;</span>,&#123;<span class="hljs-string">&quot;n1&quot;</span>:name&#125;)<span class="hljs-comment">#读取html的内容+渲染(替换)--&gt;字符串，返回给用户浏览器</span><br><br><span class="hljs-comment"># 重定向</span><br><span class="hljs-keyword">return</span> redirect(<span class="hljs-string">&quot;https://www.baidu.com&quot;</span>)<br></code></pre></td></tr></table></figure><figure class="highlight django"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs django"><span class="language-xml">避免Django表单提交出现错误，需要在form中加入语句 &quot;</span><span class="hljs-template-tag">&#123;% <span class="hljs-name"><span class="hljs-name">csrf_token</span></span> %&#125;</span><span class="language-xml">&quot;</span><br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/xiatian_grain/note_pic/raw/master/img/20231120221138.png" alt="image-20231120170840935"></p>]]></content>
    
    
    <categories>
      
      <category>Django学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Django</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>01.金蝶_一面_面经</title>
    <link href="/2023/11/02/01.%E9%87%91%E8%9D%B6_%E4%B8%80%E9%9D%A2_%E9%9D%A2%E7%BB%8F/"/>
    <url>/2023/11/02/01.%E9%87%91%E8%9D%B6_%E4%B8%80%E9%9D%A2_%E9%9D%A2%E7%BB%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="一面-10-17"><a href="#一面-10-17" class="headerlink" title="一面 10.17"></a>一面 10.17</h1><ul><li>对金蝶的了解多少？做哪些业务？</li><li>你和这个岗位的匹配度如何？你有哪些优势和缺点？</li><li>你觉得如果我们招聘你的话，你会给我们公司带来什么？</li><li>在校期间最有成就的事情</li><li>未来五年的规划</li></ul>]]></content>
    
    
    <categories>
      
      <category>秋招面经</category>
      
    </categories>
    
    
    <tags>
      
      <tag>面经</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>03.星星充电_一面_面经</title>
    <link href="/2023/11/02/03.%E6%98%9F%E6%98%9F%E5%85%85%E7%94%B5_%E4%B8%80%E9%9D%A2_%E9%9D%A2%E7%BB%8F/"/>
    <url>/2023/11/02/03.%E6%98%9F%E6%98%9F%E5%85%85%E7%94%B5_%E4%B8%80%E9%9D%A2_%E9%9D%A2%E7%BB%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="一面-10-30-（32min）"><a href="#一面-10-30-（32min）" class="headerlink" title="一面 10.30 （32min）"></a>一面 10.30 （32min）</h1><ul><li>自我介绍</li><li>介绍一下项目</li><li>怎么理解selenium web driver</li><li>那假如我要实现一个场景，用我的一个脚本，然后实现对不同的一些页面的一个兼容性验证。要用到不同版本的浏览器，比方说Chrome、火狐，还有 re ，或者是其他的浏览器，这种你觉得应该怎样去实现?（答：使用selenium grid分布式执行操作）</li><li>解释一下装饰器，它与函数的区别</li><li>解释一下什么是JSON，JSON返回的元素是有序的还是无序的</li><li>假如我现在要做两个JSON 文件的对比，一个老接口的 API输出的结果，一个新接口的输出，我想要对比这两个结果字段有没有差异，我该怎么做?</li><li>TCP、UDP介绍，区别，使用场景</li><li>get请求和post请求的区别</li><li>Linux：查看占用8080端口的进程，并结束该进程</li><li>锁的特点和机制</li><li>什么是协程？有什么特点？</li><li>对公司的了解</li><li>对常州有什么印象</li><li>你个人最大的优势？</li><li>从测试的角度看，如何保证课题的运行结果是满足要求的</li><li>课题有遇到什么难点吗</li></ul><p>反问：</p><ul><li>软测在公司负责的内容大概是什么</li><li>自动化占比？（答：自动化混合在业务中，都会有涉及，没有专门的自动化）</li></ul>]]></content>
    
    
    <categories>
      
      <category>秋招面经</category>
      
    </categories>
    
    
    <tags>
      
      <tag>面经</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>04.力维_一面+二面</title>
    <link href="/2023/11/02/04.%E5%8A%9B%E7%BB%B4_%E4%B8%80%E9%9D%A2+%E4%BA%8C%E9%9D%A2/"/>
    <url>/2023/11/02/04.%E5%8A%9B%E7%BB%B4_%E4%B8%80%E9%9D%A2+%E4%BA%8C%E9%9D%A2/</url>
    
    <content type="html"><![CDATA[<h1 id="一面-10-31-（21min）"><a href="#一面-10-31-（21min）" class="headerlink" title="一面 10.31 （21min）"></a>一面 10.31 （21min）</h1><ul><li>自我介绍</li><li>说一下整个产品生命周期，软件测试在哪些节点做哪些事</li><li>测试的目的</li><li>白盒测试和黑盒测试的区别</li><li>登录界面，设计测试用例</li><li>测试用例包括哪些内容</li><li>postman如何做接口测试</li><li>接口鉴权token在postman中如何处理</li><li>抓包工具怎么使用（fiddler）</li><li>selenium使用哪些元素定位方法</li><li>下拉菜单的元素如何获取</li><li>Linux的常用命令，文件授权命令，vim保存命令</li><li>TCP、UDP的区别</li><li>OSI模型和TCP&#x2F;IP模型的区别</li><li>MySQL中索引的定义，优缺点</li><li>MySQL删除表中数据的命令（delete from 表名 where 条件、truncate table 表名）</li><li>什么是左连接、右连接</li><li>python：字符串拆分（split）、字符串转化成大小写（upper、lower），正则表达式了解吗（不了解）</li><li>字典是什么</li></ul><h1 id="二面-11-1-（23min）"><a href="#二面-11-1-（23min）" class="headerlink" title="二面 11.1 （23min）"></a>二面 11.1 （23min）</h1><ul><li>自我介绍</li><li>研究生目前做的是什么样的工作（人工智能交叉方向）</li><li>你的研究方向好像和测试方向是两个不同的方向，你为什么选择去做测试</li><li>手头有offer吗</li><li>研究生课题是几个人负责？主要分工咋样</li><li>测试流程</li><li>测试项目介绍</li><li>数据库有用过吗</li><li>对公司的了解</li><li>做项目过程中遇到的障碍，如何攻克的</li><li>在校期间是否担任过一些职位或参加过社团活动</li><li>平时业余时间喜欢做什么工作</li><li>对于毕业后的第一份工作，你最看重什么</li><li>代码量如何</li><li>明年三四月能否实习</li></ul><p>反问：</p><p>公司中自动化测试的比例？</p>]]></content>
    
    
    <categories>
      
      <category>秋招面经</category>
      
    </categories>
    
    
    <tags>
      
      <tag>面经</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>05.TCL格创_一面</title>
    <link href="/2023/11/02/05.TCL%E6%A0%BC%E5%88%9B_%E4%B8%80%E9%9D%A2/"/>
    <url>/2023/11/02/05.TCL%E6%A0%BC%E5%88%9B_%E4%B8%80%E9%9D%A2/</url>
    
    <content type="html"><![CDATA[<h1 id="一面-11-1-（25min）"><a href="#一面-11-1-（25min）" class="headerlink" title="一面 11.1 （25min）"></a>一面 11.1 （25min）</h1><ul><li><p>自我介绍</p></li><li><p>项目介绍</p></li><li><p>购物车测试用例设计</p></li><li><p>有做过性能测试吗</p></li><li><p>数据库去重的命令（distinct、group by）</p></li><li><p>模糊匹配的语句包括（%，_）</p><ul><li>%代表任意多个字符</li><li>_代表任意一个字符</li></ul></li><li><p>浏览器键入网站后经历了哪些步骤</p></li><li><p>OSI七层模型有哪些组成</p></li><li><p><strong>链表、栈、哈希表他们的特性以及应用场景</strong></p></li><li><p><strong>索引类型、使用的存储结构（B+树）</strong></p></li><li><p>测试的基本流程</p></li><li><p>在回归测试中，如何进行测试保证问题已经解决并且不会引发其他代码问题或业务功能问题？</p></li><li><p>有做过购物车下单并发测试吗</p></li><li><p>postman压测有做过吗</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>秋招面经</category>
      
    </categories>
    
    
    <tags>
      
      <tag>面经</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>06.宇视科技_一面</title>
    <link href="/2023/11/02/06.%E5%AE%87%E8%A7%86%E7%A7%91%E6%8A%80_%E4%B8%80%E9%9D%A2/"/>
    <url>/2023/11/02/06.%E5%AE%87%E8%A7%86%E7%A7%91%E6%8A%80_%E4%B8%80%E9%9D%A2/</url>
    
    <content type="html"><![CDATA[<h1 id="一面-11-1（16min）"><a href="#一面-11-1（16min）" class="headerlink" title="一面 11.1（16min）"></a>一面 11.1（16min）</h1><ul><li>自我介绍</li><li>对测试的理解</li><li>你做测试的优势</li><li>TCP、UDP的使用场景</li><li>Linux常用命令、防火墙了解么、统计一个服务器的网口流量用什么命令</li><li>测试用例包括哪些内容</li><li>项目介绍</li><li>自动化测试的优缺点，什么情况下自动化测试是必要的？<ul><li>必要性：回归测试和版本迭代时，老的功能可以通过自动化去检验一下</li></ul></li></ul><p>反问：</p><p>公司自动化测试的比例：公司里手工测试和自动化测试是分开的，会有专门的组做自动化测试</p>]]></content>
    
    
    <categories>
      
      <category>秋招面经</category>
      
    </categories>
    
    
    <tags>
      
      <tag>面经</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>02.同程旅行_一面_面经</title>
    <link href="/2023/11/01/02.%E5%90%8C%E7%A8%8B%E6%97%85%E8%A1%8C_%E4%B8%80%E9%9D%A2_%E9%9D%A2%E7%BB%8F/"/>
    <url>/2023/11/01/02.%E5%90%8C%E7%A8%8B%E6%97%85%E8%A1%8C_%E4%B8%80%E9%9D%A2_%E9%9D%A2%E7%BB%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="一面-10-24-48min"><a href="#一面-10-24-48min" class="headerlink" title="一面 10.24 (48min)"></a>一面 10.24 (48min)</h1><ul><li><p>对于软件测试的了解</p></li><li><p>质量保障(QA)和软件测试有什么区别没有？</p><ul><li><p><strong>一、软件测试是一个过程，而软件质量保证是一个方法论。</strong></p><p>软件测试是通过执行软件的各种测试活动来检测和发现软件缺陷，例如单元测试、集成测试、系统测试等等。软件质量保障是一种方法论，它涉及管理、规划、监督和控制软件开发过程的各个方面，以确保软件产品的质量。</p></li><li><p><strong>二、软件测试着眼于软件产品的缺陷，而软件质量保证则关注软件产品的质量。</strong></p><p>软件测试是针对软件中的缺陷和错误进行的活动，例如逻辑错误、设计问题、性能问题等。软件质量保证是确保软件产品符合质量标准和用户需求的过程，包括软件设计、开发、测试、部署和维护。</p></li><li><p><strong>三、软件测试是一项技术任务，而软件质量保证是一项管理任务。</strong></p><p>软件测试需要技术人员使用各种测试工具和技术来发现和修复软件缺陷。</p><p>而软件质量保证需要管理人员制定和执行质量计划、制定和实施质量标准、指导和培训开发人员等。</p></li></ul></li><li><p>软件开发的一个整体流程</p></li><li><p>测试用例包含哪几项</p></li><li><p>购物车，测试用例</p></li><li><p>fiddler抓包原理</p></li><li><p>fiddler是否可以抓包安卓的https请求？（不可以的）</p></li><li><p>python：一个列表中嵌套字典，字典中包含名字和分数，现在需要按照分数对该列表进行排序，该怎么实现</p></li><li><p>装饰器是什么</p></li><li><p>map(), filter()和reduce()</p></li><li><p>PO模式的实现</p></li><li><p>Selenium的元素定位方法</p></li><li><p>查询所有科目成绩大于60分的学生姓名</p><ul><li><strong>select name from test_a group by name having min(scores)&gt;60;</strong></li></ul></li><li><p>http协议报文、请求方式、响应状态码</p></li><li><p>http头有哪些常见字段</p></li><li><p>接口测试测试用例从哪些方面考虑，例如登录接口的测试用例如何编写</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>秋招面经</category>
      
    </categories>
    
    
    <tags>
      
      <tag>面经</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>二叉树</title>
    <link href="/2023/09/17/01.%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <url>/2023/09/17/01.%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<p>结点：树中的元素，包含一个数据元素及若干指向子树的分支<br />结点的度：结点拥有的子树数量<br /><br><img src="/blog_img/image.png"><br><a name="A7udv"></a></p><h2 id="1、什么是二叉树？"><a href="#1、什么是二叉树？" class="headerlink" title="1、什么是二叉树？"></a>1、什么是二叉树？</h2><p><strong>定义：二叉树是每个结点最多有两个子树的树结构</strong><br /><strong>应用：</strong>1、window和linux等文件管理系统都是树型结构<br />    2、二叉树的中序遍历形式被用来存放C 语言中的表达式<br />    3、二叉排序树被用于数据的排序和快速查找。<br />    4、霍夫曼编码</p><ul><li>结点：树中的元素，包含一个数据元素及若干指向子树的分支</li><li>结点的度：结点拥有的子树数量</li><li>叶子结点就是度为0的结点</li><li><strong>二叉树的高度：</strong>指从根节点到叶子节点的最长路径上的节点数</li><li><strong>二叉树的某节点深度：</strong>指从根节点到该节点的最长路径上的节点数<br><a name="Iw6Qt"></a></li></ul><h3 id="1-1-满二叉树"><a href="#1-1-满二叉树" class="headerlink" title="1.1 满二叉树"></a>1.1 满二叉树</h3><p>如果一棵二叉树只有度为0的结点和度为2的结点，并且度为0的结点在同一层上，则这棵二叉树为满二叉树。<strong>也可以说深度为k，有2^k-1个节点的二叉树。</strong><br><a name="LnZrX"></a></p><h3 id="1-2-完全二叉树"><a href="#1-2-完全二叉树" class="headerlink" title="1.2 完全二叉树"></a>1.2 完全二叉树</h3><p>在完全二叉树中，除了最底层节点可能没填满外，其余每层节点数都达到最大值，并且最下面一层的节点都集中在该层最左边的若干位置。<strong>特点</strong>：所有子节点都出现在第k层或k-1层。<br><a name="BKOmj"></a></p><h3 id="1-3-二叉搜索树"><a href="#1-3-二叉搜索树" class="headerlink" title="1.3 二叉搜索树"></a>1.3 二叉搜索树</h3><p>二叉搜索树是一个有序树</p><ul><li>若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值；</li><li>若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值；</li><li>它的左、右子树也分别为二叉排序树<br><a name="xaBDA"></a></li></ul><h3 id="1-4-平衡二叉搜索树"><a href="#1-4-平衡二叉搜索树" class="headerlink" title="1.4 平衡二叉搜索树"></a>1.4 平衡二叉搜索树</h3><p>又称AVL树。具有以下性质：它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。</p><ul><li><strong>C++中map、set、multimap，multiset的底层实现都是平衡二叉搜索树</strong>，所以map、set的增删操作时间时间复杂度是logn<br><a name="QGY4k"></a></li></ul><h3 id="1-5-代码定义树节点"><a href="#1-5-代码定义树节点" class="headerlink" title="1.5 代码定义树节点"></a>1.5 代码定义树节点</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">TreeNode</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, val, left=<span class="hljs-literal">None</span>, right=<span class="hljs-literal">None</span></span>):<br>        self.val = val<br>        self.left = left<br>        self.right = right<br></code></pre></td></tr></table></figure><p><a name="jR37Y"></a></p><h2 id="2、二叉树遍历"><a href="#2、二叉树遍历" class="headerlink" title="2、二叉树遍历"></a>2、二叉树遍历</h2><p>二叉树主要有两种遍历方式：</p><ol><li><strong>深度优先遍历</strong>：先往深走，遇到叶子节点再往回走。</li><li><strong>广度优先遍历</strong>：一层一层的去遍历。</li></ol><ul><li>深度优先遍历<ul><li>前序遍历（递归法，迭代法）</li><li>中序遍历（递归法，迭代法）</li><li>后序遍历（递归法，迭代法）</li></ul></li><li>广度优先遍历<ul><li>层次遍历（迭代法）<br><a name="LA7Uv"></a></li></ul></li></ul><h3 id="2-1-递归遍历"><a href="#2-1-递归遍历" class="headerlink" title="2.1 递归遍历"></a>2.1 递归遍历</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">TreeNode</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, val, left=<span class="hljs-literal">None</span>, right=<span class="hljs-literal">None</span></span>):<br>        self.val = val<br>        self.left = left<br>        self.right = right<br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br><br>    <span class="hljs-comment"># 前序遍历</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">preorderTraversal</span>(<span class="hljs-params">self, root: TreeNode</span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]:<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> root:    <span class="hljs-comment"># 根节点为空就返回空列表，不用再遍历下去了。</span><br>            <span class="hljs-keyword">return</span> []<br>        left = self.preorderTraversal(root.left)<br>        right = self.preorderTraversal(root.right)<br>        <span class="hljs-keyword">return</span> [root.val] + left + right<br><br>    <span class="hljs-comment"># 中序遍历</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">inorderTraversal</span>(<span class="hljs-params">self, root: TreeNode</span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]:<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> root:<br>            <span class="hljs-keyword">return</span> []<br>        left = self.inorderTraversal(root.left)<br>        right = self.inorderTraversal(root.right)<br>        <span class="hljs-keyword">return</span> left + [root.val] + right<br><br>    <span class="hljs-comment"># 后序遍历</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">postorderTraversal</span>(<span class="hljs-params">self, root: TreeNode</span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]:<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> root:<br>            <span class="hljs-keyword">return</span> []<br>        left = self.postorderTraversal(root.left)<br>        right = self.postorderTraversal(root.right)<br>        <span class="hljs-keyword">return</span> left + right + [root.val]<br><br></code></pre></td></tr></table></figure><p><a name="se6AH"></a></p><h3 id="2-2-非递归遍历"><a href="#2-2-非递归遍历" class="headerlink" title="2.2 非递归遍历"></a>2.2 非递归遍历</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    统一格式的非递归写法</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    <span class="hljs-comment"># 前序遍历：中左右，那么代码顺序是右左中</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">preorderTraversal</span>(<span class="hljs-params">self, root: TreeNode</span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]:<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> root:<br>            <span class="hljs-keyword">return</span> []<br>        stack = [root]<br>        result = []<br>        <span class="hljs-keyword">while</span> stack:<br>            node = stack.pop()<br>            <span class="hljs-keyword">if</span> node != <span class="hljs-literal">None</span>:<br>                <span class="hljs-keyword">if</span> node.right:  <span class="hljs-comment"># 右</span><br>                    stack.append(node.right)<br>                <span class="hljs-keyword">if</span> node.left:   <span class="hljs-comment"># 左</span><br>                    stack.append(node.left)<br>                stack.append(node)  <span class="hljs-comment"># 中</span><br>                stack.append(<span class="hljs-literal">None</span>)<br>            <span class="hljs-keyword">else</span>:<br>                node = stack.pop()<br>                result.append(node.val)<br>        <span class="hljs-keyword">return</span> result<br><br>    <span class="hljs-comment"># 中序遍历：左中右，那么代码顶序是右中左</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">inorderTraversal</span>(<span class="hljs-params">self, root: TreeNode</span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]:<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> root:<br>            <span class="hljs-keyword">return</span> []<br>        stack = [root]<br>        result = []<br>        <span class="hljs-keyword">while</span> stack:<br>            node = stack.pop()<br>            <span class="hljs-keyword">if</span> node != <span class="hljs-literal">None</span>:<br>                <span class="hljs-keyword">if</span> node.right:  <span class="hljs-comment"># 右</span><br>                    stack.append(node.right)<br>                stack.append(node)  <span class="hljs-comment"># 中</span><br>                stack.append(<span class="hljs-literal">None</span>)<br>                <span class="hljs-keyword">if</span> node.left:   <span class="hljs-comment"># 左</span><br>                    stack.append(node.left)<br><br>            <span class="hljs-keyword">else</span>:<br>                node = stack.pop()<br>                result.append(node.val)<br>        <span class="hljs-keyword">return</span> result<br><br>    <span class="hljs-comment">#  后序遍历：左右中，那么代码顶序是中右左</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">inorderTraversal</span>(<span class="hljs-params">self, root: TreeNode</span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]:<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> root:<br>            <span class="hljs-keyword">return</span> []<br>        stack = [root]<br>        result = []<br>        <span class="hljs-keyword">while</span> stack:<br>            node = stack.pop()<br>            <span class="hljs-keyword">if</span> node != <span class="hljs-literal">None</span>:<br>                stack.append(node)  <span class="hljs-comment"># 中</span><br>                stack.append(<span class="hljs-literal">None</span>)<br>                <span class="hljs-keyword">if</span> node.right:  <span class="hljs-comment"># 右</span><br>                    stack.append(node.right)<br>                <span class="hljs-keyword">if</span> node.left:   <span class="hljs-comment"># 左</span><br>                    stack.append(node.left)<br>            <span class="hljs-keyword">else</span>:<br>                node = stack.pop()<br>                result.append(node.val)<br>        <span class="hljs-keyword">return</span> result          <br></code></pre></td></tr></table></figure><p><a name="pHizx"></a></p><h3 id="2-3-102-层序遍历"><a href="#2-3-102-层序遍历" class="headerlink" title="2.3  102 层序遍历"></a>2.3  102 层序遍历</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> collections<br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">TreeNode</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, val, left=<span class="hljs-literal">None</span>, right=<span class="hljs-literal">None</span></span>):<br>        self.val = val<br>        self.left = left<br>        self.right = right<br><br><span class="hljs-comment"># 利用队列法</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">levelOrder</span>(<span class="hljs-params">self, root: <span class="hljs-type">Optional</span>[TreeNode]</span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]:<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> root:    <span class="hljs-comment"># 判断根节点是否为空</span><br>            <span class="hljs-keyword">return</span> []<br>        queue = collections.deque([root])   <span class="hljs-comment"># 引入队列</span><br>        result = []<br>        <span class="hljs-keyword">while</span> queue:<br>            level = []<br>            <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(queue)):<br>                node = queue.popleft()  <span class="hljs-comment"># 从队列左端删除</span><br>                level.append(node.val)<br>                <span class="hljs-keyword">if</span> node.left:<br>                    queue.append(node.left)<br>                <span class="hljs-keyword">if</span> node.right:<br>                    queue.append(node.right)<br>            result.append(level)<br>        <span class="hljs-keyword">return</span> result<br></code></pre></td></tr></table></figure><p><a name="iqNY4"></a></p><h3 id="2-4-算法题"><a href="#2-4-算法题" class="headerlink" title="2.4 算法题"></a>2.4 算法题</h3><p><a name="c3vfT"></a></p><h4 id="107-二叉树的层序遍历II"><a href="#107-二叉树的层序遍历II" class="headerlink" title="107.二叉树的层序遍历II"></a>107.二叉树的层序遍历II</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 将层序遍历的结果倒序输出</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">levelOrderBottom</span>(<span class="hljs-params">self, root: <span class="hljs-type">Optional</span>[TreeNode]</span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]:<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> root:<br>            <span class="hljs-keyword">return</span> []     <br>        queue = collections.deque([root])<br>        result = []<br><br>        <span class="hljs-keyword">while</span> queue:<br>            level = [] <span class="hljs-comment"># 记录每一层</span><br>            n = <span class="hljs-built_in">len</span>(queue)<br>            <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>                node = queue.popleft()<br>                level.append(node.val)<br>                <span class="hljs-keyword">if</span> node.left:<br>                    queue.append(node.left)<br>                <span class="hljs-keyword">if</span> node.right:<br>                    queue.append(node.right)<br>            result.append(level)<br>        <span class="hljs-keyword">return</span> result[::-<span class="hljs-number">1</span>]<br></code></pre></td></tr></table></figure><p><a name="iogrB"></a></p><h4 id="199-二叉树的右视图"><a href="#199-二叉树的右视图" class="headerlink" title="199.二叉树的右视图"></a><a href="https://leetcode.cn/problems/binary-tree-right-side-view/">199.二叉树的右视图</a></h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">rightSideView</span>(<span class="hljs-params">self, root: <span class="hljs-type">Optional</span>[TreeNode]</span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]:<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> root:<br>            <span class="hljs-keyword">return</span> []<br>        queue = collections.deque([root])<br>        result = []<br>        <span class="hljs-keyword">while</span> queue:<br>            level = []<br>            n = <span class="hljs-built_in">len</span>(queue)<br>            <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>                node = queue.popleft()<br>                level.append(node.val)<br>                <span class="hljs-keyword">if</span> node.left:<br>                    queue.append(node.left)<br>                <span class="hljs-keyword">if</span> node.right:<br>                    queue.append(node.right)<br>            result.append(level[-<span class="hljs-number">1</span>])<span class="hljs-comment"># 将每一层的最后一位数添加到列表中</span><br>        <span class="hljs-keyword">return</span> result<br></code></pre></td></tr></table></figure><p><a name="PwPJO"></a></p><h4 id="637-二叉树的层平均值"><a href="#637-二叉树的层平均值" class="headerlink" title="637.二叉树的层平均值"></a><a href="https://leetcode.cn/problems/average-of-levels-in-binary-tree/">637.二叉树的层平均值</a></h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">averageOfLevels</span>(<span class="hljs-params">self, root: <span class="hljs-type">Optional</span>[TreeNode]</span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-built_in">float</span>]:<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> root:<br>            <span class="hljs-keyword">return</span> []<br>        <br>        queue = collections.deque([root])<br>        result = []<br>        <span class="hljs-keyword">while</span> queue:<br>            level = <span class="hljs-number">0</span><br>            n = <span class="hljs-built_in">len</span>(queue)<br>            <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>                node = queue.popleft()<br>                level += node.val<br><br>                <span class="hljs-keyword">if</span> node.left:<br>                    queue.append(node.left)<br>                <span class="hljs-keyword">if</span> node.right:<br>                    queue.append(node.right)          <br>            result.append(level/n)<br>        <span class="hljs-keyword">return</span> result<br></code></pre></td></tr></table></figure><p><a name="vjy3r"></a></p><h4 id="429-N-叉树的层序遍历"><a href="#429-N-叉树的层序遍历" class="headerlink" title="429.N 叉树的层序遍历"></a><a href="https://leetcode.cn/problems/n-ary-tree-level-order-traversal/">429.N 叉树的层序遍历</a></h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, val=<span class="hljs-literal">None</span>, children=<span class="hljs-literal">None</span></span>):<br>        self.val = val<br>        self.children = children<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">levelOrder</span>(<span class="hljs-params">self, root: <span class="hljs-string">&#x27;Node&#x27;</span></span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]:<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> root:<br>            <span class="hljs-keyword">return</span> []<br>        queue = collections.deque([root])<br>        result = []<br><br>        <span class="hljs-keyword">while</span> queue:<br>            level = []<br>            n = <span class="hljs-built_in">len</span>(queue)<br>            <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>                node = queue.popleft()<br>                level.append(node.val)<br>                <span class="hljs-keyword">for</span> child <span class="hljs-keyword">in</span> node.children:<br>                    queue.append(child)<br><br>            result.append(level)<br>        <span class="hljs-keyword">return</span> result<br></code></pre></td></tr></table></figure><p><a name="vPYE6"></a></p><h4 id="515-在每个树行中找最大值"><a href="#515-在每个树行中找最大值" class="headerlink" title="515.在每个树行中找最大值"></a><a href="https://leetcode.cn/problems/find-largest-value-in-each-tree-row/">515.在每个树行中找最大值</a></h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">largestValues</span>(<span class="hljs-params">self, root: <span class="hljs-type">Optional</span>[TreeNode]</span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]:<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> root:<br>            <span class="hljs-keyword">return</span> []<br>        queue = collections.deque([root])<br>        ans = []<br>        <span class="hljs-keyword">while</span> queue:<br>            level = []<br>            n = <span class="hljs-built_in">len</span>(queue)<br>            <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>                node = queue.popleft()<br>                level.append(node.val)<br>                <span class="hljs-keyword">if</span> node.left:<br>                    queue.append(node.left)<br>                <span class="hljs-keyword">if</span> node.right:<br>                    queue.append(node.right)<br>            ans.append(<span class="hljs-built_in">max</span>(level))<br>        <span class="hljs-keyword">return</span> ans<br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/maximum-depth-of-binary-tree/"><strong>104.二叉树的最大深度</strong></a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">maxDepth</span>(<span class="hljs-params">self, root: <span class="hljs-type">Optional</span>[TreeNode]</span>) -&gt; <span class="hljs-built_in">int</span>:<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> root:<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>        queue = collections.deque([root])<br>        ans = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">while</span> queue:<br>            ans += <span class="hljs-number">1</span><br>            n = <span class="hljs-built_in">len</span>(queue)<br>            <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>                node = queue.popleft()<br>                <span class="hljs-keyword">if</span> node.left:<br>                    queue.append(node.left)<br>                    <br>                <span class="hljs-keyword">if</span> node.right:<br>                    queue.append(node.right) <br>        <span class="hljs-keyword">return</span> ans<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">maxDepth</span>(<span class="hljs-params">self, root: <span class="hljs-type">Optional</span>[TreeNode]</span>) -&gt; <span class="hljs-built_in">int</span>:<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> root:<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>        left = self.maxDepth(node.left)<br>        right = self.maxDepth(node.right)<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(left,right) + <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>需要收集孩子节点的信息返回给上一层时，再用后续遍历</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
