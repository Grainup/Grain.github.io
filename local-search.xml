<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>二叉树</title>
    <link href="/2023/09/17/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <url>/2023/09/17/%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<p>结点：树中的元素，包含一个数据元素及若干指向子树的分支<br />结点的度：结点拥有的子树数量<br /><br><img src="/blog_img/image.png"><br><a name="A7udv"></a></p><h2 id="1、什么是二叉树？"><a href="#1、什么是二叉树？" class="headerlink" title="1、什么是二叉树？"></a>1、什么是二叉树？</h2><p><strong>定义：二叉树是每个结点最多有两个子树的树结构</strong><br /><strong>应用：</strong>1、window和linux等文件管理系统都是树型结构<br />    2、二叉树的中序遍历形式被用来存放C 语言中的表达式<br />    3、二叉排序树被用于数据的排序和快速查找。<br />    4、霍夫曼编码</p><ul><li>结点：树中的元素，包含一个数据元素及若干指向子树的分支</li><li>结点的度：结点拥有的子树数量</li><li>叶子结点就是度为0的结点</li><li><strong>二叉树的高度：</strong>指从根节点到叶子节点的最长路径上的节点数</li><li><strong>二叉树的某节点深度：</strong>指从根节点到该节点的最长路径上的节点数<br><a name="Iw6Qt"></a></li></ul><h3 id="1-1-满二叉树"><a href="#1-1-满二叉树" class="headerlink" title="1.1 满二叉树"></a>1.1 满二叉树</h3><p>如果一棵二叉树只有度为0的结点和度为2的结点，并且度为0的结点在同一层上，则这棵二叉树为满二叉树。<strong>也可以说深度为k，有2^k-1个节点的二叉树。</strong><br><a name="LnZrX"></a></p><h3 id="1-2-完全二叉树"><a href="#1-2-完全二叉树" class="headerlink" title="1.2 完全二叉树"></a>1.2 完全二叉树</h3><p>在完全二叉树中，除了最底层节点可能没填满外，其余每层节点数都达到最大值，并且最下面一层的节点都集中在该层最左边的若干位置。<strong>特点</strong>：所有子节点都出现在第k层或k-1层。<br><a name="BKOmj"></a></p><h3 id="1-3-二叉搜索树"><a href="#1-3-二叉搜索树" class="headerlink" title="1.3 二叉搜索树"></a>1.3 二叉搜索树</h3><p>二叉搜索树是一个有序树</p><ul><li>若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值；</li><li>若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值；</li><li>它的左、右子树也分别为二叉排序树<br><a name="xaBDA"></a></li></ul><h3 id="1-4-平衡二叉搜索树"><a href="#1-4-平衡二叉搜索树" class="headerlink" title="1.4 平衡二叉搜索树"></a>1.4 平衡二叉搜索树</h3><p>又称AVL树。具有以下性质：它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。</p><ul><li><strong>C++中map、set、multimap，multiset的底层实现都是平衡二叉搜索树</strong>，所以map、set的增删操作时间时间复杂度是logn<br><a name="QGY4k"></a></li></ul><h3 id="1-5-代码定义树节点"><a href="#1-5-代码定义树节点" class="headerlink" title="1.5 代码定义树节点"></a>1.5 代码定义树节点</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">TreeNode</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, val, left=<span class="hljs-literal">None</span>, right=<span class="hljs-literal">None</span></span>):<br>        self.val = val<br>        self.left = left<br>        self.right = right<br></code></pre></td></tr></table></figure><p><a name="jR37Y"></a></p><h2 id="2、二叉树遍历"><a href="#2、二叉树遍历" class="headerlink" title="2、二叉树遍历"></a>2、二叉树遍历</h2><p>二叉树主要有两种遍历方式：</p><ol><li><strong>深度优先遍历</strong>：先往深走，遇到叶子节点再往回走。</li><li><strong>广度优先遍历</strong>：一层一层的去遍历。</li></ol><ul><li>深度优先遍历<ul><li>前序遍历（递归法，迭代法）</li><li>中序遍历（递归法，迭代法）</li><li>后序遍历（递归法，迭代法）</li></ul></li><li>广度优先遍历<ul><li>层次遍历（迭代法）<br><a name="LA7Uv"></a></li></ul></li></ul><h3 id="2-1-递归遍历"><a href="#2-1-递归遍历" class="headerlink" title="2.1 递归遍历"></a>2.1 递归遍历</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">TreeNode</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, val, left=<span class="hljs-literal">None</span>, right=<span class="hljs-literal">None</span></span>):<br>        self.val = val<br>        self.left = left<br>        self.right = right<br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br><br>    <span class="hljs-comment"># 前序遍历</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">preorderTraversal</span>(<span class="hljs-params">self, root: TreeNode</span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]:<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> root:    <span class="hljs-comment"># 根节点为空就返回空列表，不用再遍历下去了。</span><br>            <span class="hljs-keyword">return</span> []<br>        left = self.preorderTraversal(root.left)<br>        right = self.preorderTraversal(root.right)<br>        <span class="hljs-keyword">return</span> [root.val] + left + right<br><br>    <span class="hljs-comment"># 中序遍历</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">inorderTraversal</span>(<span class="hljs-params">self, root: TreeNode</span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]:<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> root:<br>            <span class="hljs-keyword">return</span> []<br>        left = self.inorderTraversal(root.left)<br>        right = self.inorderTraversal(root.right)<br>        <span class="hljs-keyword">return</span> left + [root.val] + right<br><br>    <span class="hljs-comment"># 后序遍历</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">postorderTraversal</span>(<span class="hljs-params">self, root: TreeNode</span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]:<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> root:<br>            <span class="hljs-keyword">return</span> []<br>        left = self.postorderTraversal(root.left)<br>        right = self.postorderTraversal(root.right)<br>        <span class="hljs-keyword">return</span> left + right + [root.val]<br><br></code></pre></td></tr></table></figure><p><a name="se6AH"></a></p><h3 id="2-2-非递归遍历"><a href="#2-2-非递归遍历" class="headerlink" title="2.2 非递归遍历"></a>2.2 非递归遍历</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    统一格式的非递归写法</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    <span class="hljs-comment"># 前序遍历：中左右，那么代码顺序是右左中</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">preorderTraversal</span>(<span class="hljs-params">self, root: TreeNode</span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]:<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> root:<br>            <span class="hljs-keyword">return</span> []<br>        stack = [root]<br>        result = []<br>        <span class="hljs-keyword">while</span> stack:<br>            node = stack.pop()<br>            <span class="hljs-keyword">if</span> node != <span class="hljs-literal">None</span>:<br>                <span class="hljs-keyword">if</span> node.right:  <span class="hljs-comment"># 右</span><br>                    stack.append(node.right)<br>                <span class="hljs-keyword">if</span> node.left:   <span class="hljs-comment"># 左</span><br>                    stack.append(node.left)<br>                stack.append(node)  <span class="hljs-comment"># 中</span><br>                stack.append(<span class="hljs-literal">None</span>)<br>            <span class="hljs-keyword">else</span>:<br>                node = stack.pop()<br>                result.append(node.val)<br>        <span class="hljs-keyword">return</span> result<br><br>    <span class="hljs-comment"># 中序遍历：左中右，那么代码顶序是右中左</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">inorderTraversal</span>(<span class="hljs-params">self, root: TreeNode</span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]:<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> root:<br>            <span class="hljs-keyword">return</span> []<br>        stack = [root]<br>        result = []<br>        <span class="hljs-keyword">while</span> stack:<br>            node = stack.pop()<br>            <span class="hljs-keyword">if</span> node != <span class="hljs-literal">None</span>:<br>                <span class="hljs-keyword">if</span> node.right:  <span class="hljs-comment"># 右</span><br>                    stack.append(node.right)<br>                stack.append(node)  <span class="hljs-comment"># 中</span><br>                stack.append(<span class="hljs-literal">None</span>)<br>                <span class="hljs-keyword">if</span> node.left:   <span class="hljs-comment"># 左</span><br>                    stack.append(node.left)<br><br>            <span class="hljs-keyword">else</span>:<br>                node = stack.pop()<br>                result.append(node.val)<br>        <span class="hljs-keyword">return</span> result<br><br>    <span class="hljs-comment">#  后序遍历：左右中，那么代码顶序是中右左</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">inorderTraversal</span>(<span class="hljs-params">self, root: TreeNode</span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]:<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> root:<br>            <span class="hljs-keyword">return</span> []<br>        stack = [root]<br>        result = []<br>        <span class="hljs-keyword">while</span> stack:<br>            node = stack.pop()<br>            <span class="hljs-keyword">if</span> node != <span class="hljs-literal">None</span>:<br>                stack.append(node)  <span class="hljs-comment"># 中</span><br>                stack.append(<span class="hljs-literal">None</span>)<br>                <span class="hljs-keyword">if</span> node.right:  <span class="hljs-comment"># 右</span><br>                    stack.append(node.right)<br>                <span class="hljs-keyword">if</span> node.left:   <span class="hljs-comment"># 左</span><br>                    stack.append(node.left)<br>            <span class="hljs-keyword">else</span>:<br>                node = stack.pop()<br>                result.append(node.val)<br>        <span class="hljs-keyword">return</span> result          <br></code></pre></td></tr></table></figure><p><a name="pHizx"></a></p><h3 id="2-3-102-层序遍历"><a href="#2-3-102-层序遍历" class="headerlink" title="2.3  102 层序遍历"></a>2.3  102 层序遍历</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> collections<br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">TreeNode</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, val, left=<span class="hljs-literal">None</span>, right=<span class="hljs-literal">None</span></span>):<br>        self.val = val<br>        self.left = left<br>        self.right = right<br><br><span class="hljs-comment"># 利用队列法</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">levelOrder</span>(<span class="hljs-params">self, root: <span class="hljs-type">Optional</span>[TreeNode]</span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]:<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> root:    <span class="hljs-comment"># 判断根节点是否为空</span><br>            <span class="hljs-keyword">return</span> []<br>        queue = collections.deque([root])   <span class="hljs-comment"># 引入队列</span><br>        result = []<br>        <span class="hljs-keyword">while</span> queue:<br>            level = []<br>            <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(queue)):<br>                node = queue.popleft()  <span class="hljs-comment"># 从队列左端删除</span><br>                level.append(node.val)<br>                <span class="hljs-keyword">if</span> node.left:<br>                    queue.append(node.left)<br>                <span class="hljs-keyword">if</span> node.right:<br>                    queue.append(node.right)<br>            result.append(level)<br>        <span class="hljs-keyword">return</span> result<br></code></pre></td></tr></table></figure><p><a name="iqNY4"></a></p><h3 id="2-4-算法题"><a href="#2-4-算法题" class="headerlink" title="2.4 算法题"></a>2.4 算法题</h3><p><a name="c3vfT"></a></p><h4 id="107-二叉树的层序遍历II"><a href="#107-二叉树的层序遍历II" class="headerlink" title="107.二叉树的层序遍历II"></a>107.二叉树的层序遍历II</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 将层序遍历的结果倒序输出</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">levelOrderBottom</span>(<span class="hljs-params">self, root: <span class="hljs-type">Optional</span>[TreeNode]</span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]:<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> root:<br>            <span class="hljs-keyword">return</span> []     <br>        queue = collections.deque([root])<br>        result = []<br><br>        <span class="hljs-keyword">while</span> queue:<br>            level = [] <span class="hljs-comment"># 记录每一层</span><br>            n = <span class="hljs-built_in">len</span>(queue)<br>            <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>                node = queue.popleft()<br>                level.append(node.val)<br>                <span class="hljs-keyword">if</span> node.left:<br>                    queue.append(node.left)<br>                <span class="hljs-keyword">if</span> node.right:<br>                    queue.append(node.right)<br>            result.append(level)<br>        <span class="hljs-keyword">return</span> result[::-<span class="hljs-number">1</span>]<br></code></pre></td></tr></table></figure><p><a name="iogrB"></a></p><h4 id="199-二叉树的右视图"><a href="#199-二叉树的右视图" class="headerlink" title="199.二叉树的右视图"></a><a href="https://leetcode.cn/problems/binary-tree-right-side-view/">199.二叉树的右视图</a></h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">rightSideView</span>(<span class="hljs-params">self, root: <span class="hljs-type">Optional</span>[TreeNode]</span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]:<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> root:<br>            <span class="hljs-keyword">return</span> []<br>        queue = collections.deque([root])<br>        result = []<br>        <span class="hljs-keyword">while</span> queue:<br>            level = []<br>            n = <span class="hljs-built_in">len</span>(queue)<br>            <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>                node = queue.popleft()<br>                level.append(node.val)<br>                <span class="hljs-keyword">if</span> node.left:<br>                    queue.append(node.left)<br>                <span class="hljs-keyword">if</span> node.right:<br>                    queue.append(node.right)<br>            result.append(level[-<span class="hljs-number">1</span>])<span class="hljs-comment"># 将每一层的最后一位数添加到列表中</span><br>        <span class="hljs-keyword">return</span> result<br></code></pre></td></tr></table></figure><p><a name="PwPJO"></a></p><h4 id="637-二叉树的层平均值"><a href="#637-二叉树的层平均值" class="headerlink" title="637.二叉树的层平均值"></a><a href="https://leetcode.cn/problems/average-of-levels-in-binary-tree/">637.二叉树的层平均值</a></h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">averageOfLevels</span>(<span class="hljs-params">self, root: <span class="hljs-type">Optional</span>[TreeNode]</span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-built_in">float</span>]:<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> root:<br>            <span class="hljs-keyword">return</span> []<br>        <br>        queue = collections.deque([root])<br>        result = []<br>        <span class="hljs-keyword">while</span> queue:<br>            level = <span class="hljs-number">0</span><br>            n = <span class="hljs-built_in">len</span>(queue)<br>            <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>                node = queue.popleft()<br>                level += node.val<br><br>                <span class="hljs-keyword">if</span> node.left:<br>                    queue.append(node.left)<br>                <span class="hljs-keyword">if</span> node.right:<br>                    queue.append(node.right)          <br>            result.append(level/n)<br>        <span class="hljs-keyword">return</span> result<br></code></pre></td></tr></table></figure><p><a name="vjy3r"></a></p><h4 id="429-N-叉树的层序遍历"><a href="#429-N-叉树的层序遍历" class="headerlink" title="429.N 叉树的层序遍历"></a><a href="https://leetcode.cn/problems/n-ary-tree-level-order-traversal/">429.N 叉树的层序遍历</a></h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, val=<span class="hljs-literal">None</span>, children=<span class="hljs-literal">None</span></span>):<br>        self.val = val<br>        self.children = children<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">levelOrder</span>(<span class="hljs-params">self, root: <span class="hljs-string">&#x27;Node&#x27;</span></span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]:<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> root:<br>            <span class="hljs-keyword">return</span> []<br>        queue = collections.deque([root])<br>        result = []<br><br>        <span class="hljs-keyword">while</span> queue:<br>            level = []<br>            n = <span class="hljs-built_in">len</span>(queue)<br>            <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>                node = queue.popleft()<br>                level.append(node.val)<br>                <span class="hljs-keyword">for</span> child <span class="hljs-keyword">in</span> node.children:<br>                    queue.append(child)<br><br>            result.append(level)<br>        <span class="hljs-keyword">return</span> result<br></code></pre></td></tr></table></figure><p><a name="vPYE6"></a></p><h4 id="515-在每个树行中找最大值"><a href="#515-在每个树行中找最大值" class="headerlink" title="515.在每个树行中找最大值"></a><a href="https://leetcode.cn/problems/find-largest-value-in-each-tree-row/">515.在每个树行中找最大值</a></h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">largestValues</span>(<span class="hljs-params">self, root: <span class="hljs-type">Optional</span>[TreeNode]</span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]:<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> root:<br>            <span class="hljs-keyword">return</span> []<br>        queue = collections.deque([root])<br>        ans = []<br>        <span class="hljs-keyword">while</span> queue:<br>            level = []<br>            n = <span class="hljs-built_in">len</span>(queue)<br>            <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>                node = queue.popleft()<br>                level.append(node.val)<br>                <span class="hljs-keyword">if</span> node.left:<br>                    queue.append(node.left)<br>                <span class="hljs-keyword">if</span> node.right:<br>                    queue.append(node.right)<br>            ans.append(<span class="hljs-built_in">max</span>(level))<br>        <span class="hljs-keyword">return</span> ans<br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/maximum-depth-of-binary-tree/"><strong>104.二叉树的最大深度</strong></a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">maxDepth</span>(<span class="hljs-params">self, root: <span class="hljs-type">Optional</span>[TreeNode]</span>) -&gt; <span class="hljs-built_in">int</span>:<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> root:<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>        queue = collections.deque([root])<br>        ans = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">while</span> queue:<br>            ans += <span class="hljs-number">1</span><br>            n = <span class="hljs-built_in">len</span>(queue)<br>            <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>                node = queue.popleft()<br>                <span class="hljs-keyword">if</span> node.left:<br>                    queue.append(node.left)<br>                    <br>                <span class="hljs-keyword">if</span> node.right:<br>                    queue.append(node.right) <br>        <span class="hljs-keyword">return</span> ans<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">maxDepth</span>(<span class="hljs-params">self, root: <span class="hljs-type">Optional</span>[TreeNode]</span>) -&gt; <span class="hljs-built_in">int</span>:<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> root:<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>        left = self.maxDepth(node.left)<br>        right = self.maxDepth(node.right)<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(left,right) + <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>需要收集孩子节点的信息返回给上一层时，再用后续遍历</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>测试文档</title>
    <link href="/2023/09/17/%E6%B5%8B%E8%AF%95/"/>
    <url>/2023/09/17/%E6%B5%8B%E8%AF%95/</url>
    
    <content type="html"><![CDATA[<p>测试</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;test!&#x27;</span>)<br></code></pre></td></tr></table></figure><p><img src="/img/default.png"></p><h2 id="123"><a href="#123" class="headerlink" title="123"></a>123</h2><h3 id="123-1"><a href="#123-1" class="headerlink" title="123"></a>123</h3>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>测试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2023/09/17/hello-world/"/>
    <url>/2023/09/17/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
